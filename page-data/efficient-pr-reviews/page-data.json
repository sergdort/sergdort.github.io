{"componentChunkName":"component---src-templates-blog-post-js","path":"/efficient-pr-reviews/","result":{"data":{"site":{"siteMetadata":{"title":"Journey before destination, tests before production"}},"markdownRemark":{"id":"a8154907-905b-597d-abd1-8521d10ff9fa","excerpt":"There’s no shortage of articles on why teams should adopt PR reviews. Instead of rehashing that, I want to share what’s worked for us at Sphere—a small team of…","html":"<p>There’s no shortage of articles on why teams should adopt PR reviews. Instead of rehashing that, I want to share what’s worked for us at Sphere—a small team of 2 iOS and 2 Android engineers operating in a startup environment where shipping quality features fast is non-negotiable.</p>\n<p>I recently pulled the numbers since we migrated from GitHub to GitLab: since May 28th, 4 engineers (mostly 2, since Android only recently moved to our monorepo) merged 257 PRs. That’s roughly 4.28 PRs per day.</p>\n<h2>What made this possible</h2>\n<h3>Shared architecture patterns</h3>\n<p>We standardized on common patterns across both our Domain layer (in our shared <a href=\"https://kotlinlang.org/docs/multiplatform.html\">KMM</a> library) and UI layer (where we use <a href=\"https://amsterdamstandard.com/en/post/modern-android-architecture-with-mvi-design-pattern\">MVI</a> powered by <a href=\"https://github.com/ReactiveCocoa/Loop\">Loop</a>). When everyone knows how a feature is structured, reviewers don’t waste time deciphering code organization.</p>\n<h3>High trust, low friction</h3>\n<p>When reviewing, I don’t obsess over algorithm correctness. Bugs can be fixed—especially when features ship behind feature flags. Trust your teammates to write working code.</p>\n<h3>Approve early</h3>\n<p>We approve PRs even when comments remain. We only “Request Changes” when a follow-up review is genuinely needed. This is my favorite practice: no more pinging someone to re-approve after addressing minor feedback.</p>\n<h3>Small PRs</h3>\n<p>A good PR takes 1-2 minutes to review. We achieve this through stacked branches—once there’s an independent, reviewable chunk of work, open a PR and branch off to continue.</p>\n<h2>Common mistakes to avoid</h2>\n<h3>Architecture without consistency</h3>\n<p>A team might claim to use MVVM or MVP, but if every ViewModel or Presenter is structured differently, the architecture label is meaningless. What matters are the concrete patterns: how user input flows, how state propagates to the UI, how views are constructed.</p>\n<h3>Architecture debates in PR comments</h3>\n<p>This is probably the most common mistake. By the time code hits a PR, it’s too late for architectural feedback. Complex features that affect the broader codebase need earlier discussion—proposals, RFCs, design spikes, or technical presentations.</p>\n<h3>Nitpicking</h3>\n<p>Everyone finds nitpicks annoying, especially when they block approval. Automate style enforcement with linters and formatters. Save human review time for what matters.</p>\n<h3>Large PRs</h3>\n<p>Large PRs kill velocity. Reviewers procrastinate on them, reviews happen in fragments, and context gets lost. Break them up.</p>\n<h3>Adversarial tone</h3>\n<p>Finally, watch the language in comments. Drop “I” and “you”—it’s about “we” and the team. Code review is collaborative, not adversarial.</p>","frontmatter":{"title":"Efficient PR reviews","date":"August 25, 2021","tags":["engineering-practices","code-review","teamwork"]}},"previous":{"fields":{"slug":"/swiftui-navigation-done-right/"},"frontmatter":{"title":"SwiftUI Navigation Done Right"}},"next":{"fields":{"slug":"/collection-view-insert-in-front/"},"frontmatter":{"title":"Inserting Dynamic Height Cells While Preserving Scroll Position"}}},"pageContext":{"id":"a8154907-905b-597d-abd1-8521d10ff9fa","slug":"/efficient-pr-reviews/","previousPostId":"4d2739c4-0f36-5dcc-920f-02b28c7fe34f","nextPostId":"702ad07c-baca-58b1-863d-56ebff98665b"}},"staticQueryHashes":["63159454"],"slicesMap":{}}